/* udisks2.vapi generated by vapigen, do not modify. */

[CCode (cprefix = "UDisks", gir_namespace = "UDisks", gir_version = "2.0", lower_case_cprefix = "udisks_")]
namespace UDisks {
	[CCode (cheader_filename = "udisks/udisks.h", type_id = "udisks_block_proxy_get_type ()")]
	public class BlockProxy : GLib.DBusProxy, GLib.AsyncInitable, GLib.DBusInterface, GLib.Initable, UDisks.Block {
		[CCode (cname = "udisks_block_proxy_new", has_construct_function = false)]
		public async BlockProxy (GLib.DBusConnection connection, GLib.DBusProxyFlags flags, string? name, string object_path, GLib.Cancellable? cancellable) throws GLib.Error;
		[CCode (cname = "udisks_block_proxy_new_for_bus", has_construct_function = false)]
		public async BlockProxy.for_bus (GLib.BusType bus_type, GLib.DBusProxyFlags flags, string name, string object_path, GLib.Cancellable? cancellable) throws GLib.Error;
		[CCode (has_construct_function = false, type = "UDisksBlock*")]
		public BlockProxy.for_bus_sync (GLib.BusType bus_type, GLib.DBusProxyFlags flags, string name, string object_path, GLib.Cancellable? cancellable = null) throws GLib.Error;
		[CCode (has_construct_function = false, type = "UDisksBlock*")]
		public BlockProxy.sync (GLib.DBusConnection connection, GLib.DBusProxyFlags flags, string? name, string object_path, GLib.Cancellable? cancellable = null) throws GLib.Error;
	}
	[CCode (cheader_filename = "udisks/udisks.h", type_id = "udisks_block_skeleton_get_type ()")]
	public class BlockSkeleton : GLib.DBusInterfaceSkeleton, GLib.DBusInterface, UDisks.Block {
		[CCode (has_construct_function = false, type = "UDisksBlock*")]
		public BlockSkeleton ();
	}
	[CCode (cheader_filename = "udisks/udisks.h", type_id = "udisks_client_get_type ()")]
	public class Client : GLib.Object, GLib.AsyncInitable, GLib.Initable {
		[CCode (cname = "udisks_client_new", has_construct_function = false)]
		public async Client (GLib.Cancellable? cancellable) throws GLib.Error;
		public UDisks.Block get_block_for_dev (int block_device_number);
		public UDisks.Block get_block_for_drive (UDisks.Drive drive, bool get_physical);
		public GLib.List<UDisks.Block> get_block_for_label (string label);
		public GLib.List<UDisks.Block> get_block_for_uuid (string uuid);
		public UDisks.Block get_cleartext_block (UDisks.Block block);
		public UDisks.Drive get_drive_for_block (UDisks.Block block);
		public void get_drive_info (UDisks.Drive drive, out string out_name, out string out_description, out GLib.Icon out_drive_icon, out string out_media_description, out GLib.Icon out_media_icon);
		public string get_id_for_display (string usage, string type, string version, bool long_string);
		public GLib.List<UDisks.Job> get_jobs_for_object (UDisks.Object object);
		public UDisks.Loop get_loop_for_block (UDisks.Block block);
		public unowned UDisks.Manager get_manager ();
		public string get_media_compat_for_display (string media_compat);
		public UDisks.Object get_object (string object_path);
		public unowned GLib.DBusObjectManager get_object_manager ();
		public string get_partition_info (UDisks.Partition partition);
		public UDisks.PartitionTable get_partition_table (UDisks.Partition partition);
		public unowned string get_partition_table_subtype_for_display (string partition_table_type, string partition_table_subtype);
		[CCode (array_length = false, array_null_terminated = true)]
		public string[] get_partition_table_subtypes (string partition_table_type);
		public unowned string get_partition_table_type_for_display (string partition_table_type);
		public unowned string get_partition_type_for_display (string partition_table_type, string partition_type);
		public GLib.List<UDisks.PartitionTypeInfo> get_partition_type_infos (string partition_table_type, string? partition_table_subtype);
		public GLib.List<UDisks.Partition> get_partitions (UDisks.PartitionTable table);
		public string get_size_for_display (uint64 size, bool use_pow2, bool long_string);
		public unowned UDisks.Object peek_object (string object_path);
		public void settle ();
		[CCode (has_construct_function = false)]
		public Client.sync (GLib.Cancellable? cancellable = null) throws GLib.Error;
		public UDisks.Manager manager { get; }
		public GLib.DBusObjectManager object_manager { get; }
		public signal void changed ();
	}
	[CCode (cheader_filename = "udisks/udisks.h", type_id = "udisks_drive_ata_proxy_get_type ()")]
	public class DriveAtaProxy : GLib.DBusProxy, GLib.AsyncInitable, GLib.DBusInterface, GLib.Initable, UDisks.DriveAta {
		[CCode (cname = "udisks_drive_ata_proxy_new", has_construct_function = false)]
		public async DriveAtaProxy (GLib.DBusConnection connection, GLib.DBusProxyFlags flags, string? name, string object_path, GLib.Cancellable? cancellable) throws GLib.Error;
		[CCode (cname = "udisks_drive_ata_proxy_new_for_bus", has_construct_function = false)]
		public async DriveAtaProxy.for_bus (GLib.BusType bus_type, GLib.DBusProxyFlags flags, string name, string object_path, GLib.Cancellable? cancellable) throws GLib.Error;
		[CCode (has_construct_function = false, type = "UDisksDriveAta*")]
		public DriveAtaProxy.for_bus_sync (GLib.BusType bus_type, GLib.DBusProxyFlags flags, string name, string object_path, GLib.Cancellable? cancellable = null) throws GLib.Error;
		[CCode (has_construct_function = false, type = "UDisksDriveAta*")]
		public DriveAtaProxy.sync (GLib.DBusConnection connection, GLib.DBusProxyFlags flags, string? name, string object_path, GLib.Cancellable? cancellable = null) throws GLib.Error;
	}
	[CCode (cheader_filename = "udisks/udisks.h", type_id = "udisks_drive_ata_skeleton_get_type ()")]
	public class DriveAtaSkeleton : GLib.DBusInterfaceSkeleton, GLib.DBusInterface, UDisks.DriveAta {
		[CCode (has_construct_function = false, type = "UDisksDriveAta*")]
		public DriveAtaSkeleton ();
	}
	[CCode (cheader_filename = "udisks/udisks.h", type_id = "udisks_drive_proxy_get_type ()")]
	public class DriveProxy : GLib.DBusProxy, GLib.AsyncInitable, GLib.DBusInterface, GLib.Initable, UDisks.Drive {
		[CCode (cname = "udisks_drive_proxy_new", has_construct_function = false)]
		public async DriveProxy (GLib.DBusConnection connection, GLib.DBusProxyFlags flags, string? name, string object_path, GLib.Cancellable? cancellable) throws GLib.Error;
		[CCode (cname = "udisks_drive_proxy_new_for_bus", has_construct_function = false)]
		public async DriveProxy.for_bus (GLib.BusType bus_type, GLib.DBusProxyFlags flags, string name, string object_path, GLib.Cancellable? cancellable) throws GLib.Error;
		[CCode (has_construct_function = false, type = "UDisksDrive*")]
		public DriveProxy.for_bus_sync (GLib.BusType bus_type, GLib.DBusProxyFlags flags, string name, string object_path, GLib.Cancellable? cancellable = null) throws GLib.Error;
		[CCode (has_construct_function = false, type = "UDisksDrive*")]
		public DriveProxy.sync (GLib.DBusConnection connection, GLib.DBusProxyFlags flags, string? name, string object_path, GLib.Cancellable? cancellable = null) throws GLib.Error;
	}
	[CCode (cheader_filename = "udisks/udisks.h", type_id = "udisks_drive_skeleton_get_type ()")]
	public class DriveSkeleton : GLib.DBusInterfaceSkeleton, GLib.DBusInterface, UDisks.Drive {
		[CCode (has_construct_function = false, type = "UDisksDrive*")]
		public DriveSkeleton ();
	}
	[CCode (cheader_filename = "udisks/udisks.h", type_id = "udisks_encrypted_proxy_get_type ()")]
	public class EncryptedProxy : GLib.DBusProxy, GLib.AsyncInitable, GLib.DBusInterface, GLib.Initable, UDisks.Encrypted {
		[CCode (cname = "udisks_encrypted_proxy_new", has_construct_function = false)]
		public async EncryptedProxy (GLib.DBusConnection connection, GLib.DBusProxyFlags flags, string? name, string object_path, GLib.Cancellable? cancellable) throws GLib.Error;
		[CCode (cname = "udisks_encrypted_proxy_new_for_bus", has_construct_function = false)]
		public async EncryptedProxy.for_bus (GLib.BusType bus_type, GLib.DBusProxyFlags flags, string name, string object_path, GLib.Cancellable? cancellable) throws GLib.Error;
		[CCode (has_construct_function = false, type = "UDisksEncrypted*")]
		public EncryptedProxy.for_bus_sync (GLib.BusType bus_type, GLib.DBusProxyFlags flags, string name, string object_path, GLib.Cancellable? cancellable = null) throws GLib.Error;
		[CCode (has_construct_function = false, type = "UDisksEncrypted*")]
		public EncryptedProxy.sync (GLib.DBusConnection connection, GLib.DBusProxyFlags flags, string? name, string object_path, GLib.Cancellable? cancellable = null) throws GLib.Error;
	}
	[CCode (cheader_filename = "udisks/udisks.h", type_id = "udisks_encrypted_skeleton_get_type ()")]
	public class EncryptedSkeleton : GLib.DBusInterfaceSkeleton, GLib.DBusInterface, UDisks.Encrypted {
		[CCode (has_construct_function = false, type = "UDisksEncrypted*")]
		public EncryptedSkeleton ();
	}
	[CCode (cheader_filename = "udisks/udisks.h", type_id = "udisks_filesystem_proxy_get_type ()")]
	public class FilesystemProxy : GLib.DBusProxy, GLib.AsyncInitable, GLib.DBusInterface, GLib.Initable, UDisks.Filesystem {
		[CCode (cname = "udisks_filesystem_proxy_new", has_construct_function = false)]
		public async FilesystemProxy (GLib.DBusConnection connection, GLib.DBusProxyFlags flags, string? name, string object_path, GLib.Cancellable? cancellable) throws GLib.Error;
		[CCode (cname = "udisks_filesystem_proxy_new_for_bus", has_construct_function = false)]
		public async FilesystemProxy.for_bus (GLib.BusType bus_type, GLib.DBusProxyFlags flags, string name, string object_path, GLib.Cancellable? cancellable) throws GLib.Error;
		[CCode (has_construct_function = false, type = "UDisksFilesystem*")]
		public FilesystemProxy.for_bus_sync (GLib.BusType bus_type, GLib.DBusProxyFlags flags, string name, string object_path, GLib.Cancellable? cancellable = null) throws GLib.Error;
		[CCode (has_construct_function = false, type = "UDisksFilesystem*")]
		public FilesystemProxy.sync (GLib.DBusConnection connection, GLib.DBusProxyFlags flags, string? name, string object_path, GLib.Cancellable? cancellable = null) throws GLib.Error;
	}
	[CCode (cheader_filename = "udisks/udisks.h", type_id = "udisks_filesystem_skeleton_get_type ()")]
	public class FilesystemSkeleton : GLib.DBusInterfaceSkeleton, GLib.DBusInterface, UDisks.Filesystem {
		[CCode (has_construct_function = false, type = "UDisksFilesystem*")]
		public FilesystemSkeleton ();
	}
	[CCode (cheader_filename = "udisks/udisks.h", type_id = "udisks_job_proxy_get_type ()")]
	public class JobProxy : GLib.DBusProxy, GLib.AsyncInitable, GLib.DBusInterface, GLib.Initable, UDisks.Job {
		[CCode (cname = "udisks_job_proxy_new", has_construct_function = false)]
		public async JobProxy (GLib.DBusConnection connection, GLib.DBusProxyFlags flags, string? name, string object_path, GLib.Cancellable? cancellable) throws GLib.Error;
		[CCode (cname = "udisks_job_proxy_new_for_bus", has_construct_function = false)]
		public async JobProxy.for_bus (GLib.BusType bus_type, GLib.DBusProxyFlags flags, string name, string object_path, GLib.Cancellable? cancellable) throws GLib.Error;
		[CCode (has_construct_function = false, type = "UDisksJob*")]
		public JobProxy.for_bus_sync (GLib.BusType bus_type, GLib.DBusProxyFlags flags, string name, string object_path, GLib.Cancellable? cancellable = null) throws GLib.Error;
		[CCode (has_construct_function = false, type = "UDisksJob*")]
		public JobProxy.sync (GLib.DBusConnection connection, GLib.DBusProxyFlags flags, string? name, string object_path, GLib.Cancellable? cancellable = null) throws GLib.Error;
	}
	[CCode (cheader_filename = "udisks/udisks.h", type_id = "udisks_job_skeleton_get_type ()")]
	public class JobSkeleton : GLib.DBusInterfaceSkeleton, GLib.DBusInterface, UDisks.Job {
		[CCode (has_construct_function = false, type = "UDisksJob*")]
		public JobSkeleton ();
	}
	[CCode (cheader_filename = "udisks/udisks.h", type_id = "udisks_loop_proxy_get_type ()")]
	public class LoopProxy : GLib.DBusProxy, GLib.AsyncInitable, GLib.DBusInterface, GLib.Initable, UDisks.Loop {
		[CCode (cname = "udisks_loop_proxy_new", has_construct_function = false)]
		public async LoopProxy (GLib.DBusConnection connection, GLib.DBusProxyFlags flags, string? name, string object_path, GLib.Cancellable? cancellable) throws GLib.Error;
		[CCode (cname = "udisks_loop_proxy_new_for_bus", has_construct_function = false)]
		public async LoopProxy.for_bus (GLib.BusType bus_type, GLib.DBusProxyFlags flags, string name, string object_path, GLib.Cancellable? cancellable) throws GLib.Error;
		[CCode (has_construct_function = false, type = "UDisksLoop*")]
		public LoopProxy.for_bus_sync (GLib.BusType bus_type, GLib.DBusProxyFlags flags, string name, string object_path, GLib.Cancellable? cancellable = null) throws GLib.Error;
		[CCode (has_construct_function = false, type = "UDisksLoop*")]
		public LoopProxy.sync (GLib.DBusConnection connection, GLib.DBusProxyFlags flags, string? name, string object_path, GLib.Cancellable? cancellable = null) throws GLib.Error;
	}
	[CCode (cheader_filename = "udisks/udisks.h", type_id = "udisks_loop_skeleton_get_type ()")]
	public class LoopSkeleton : GLib.DBusInterfaceSkeleton, GLib.DBusInterface, UDisks.Loop {
		[CCode (has_construct_function = false, type = "UDisksLoop*")]
		public LoopSkeleton ();
	}
	[CCode (cheader_filename = "udisks/udisks.h", type_id = "udisks_manager_proxy_get_type ()")]
	public class ManagerProxy : GLib.DBusProxy, GLib.AsyncInitable, GLib.DBusInterface, GLib.Initable, UDisks.Manager {
		[CCode (cname = "udisks_manager_proxy_new", has_construct_function = false)]
		public async ManagerProxy (GLib.DBusConnection connection, GLib.DBusProxyFlags flags, string? name, string object_path, GLib.Cancellable? cancellable) throws GLib.Error;
		[CCode (cname = "udisks_manager_proxy_new_for_bus", has_construct_function = false)]
		public async ManagerProxy.for_bus (GLib.BusType bus_type, GLib.DBusProxyFlags flags, string name, string object_path, GLib.Cancellable? cancellable) throws GLib.Error;
		[CCode (has_construct_function = false, type = "UDisksManager*")]
		public ManagerProxy.for_bus_sync (GLib.BusType bus_type, GLib.DBusProxyFlags flags, string name, string object_path, GLib.Cancellable? cancellable = null) throws GLib.Error;
		[CCode (has_construct_function = false, type = "UDisksManager*")]
		public ManagerProxy.sync (GLib.DBusConnection connection, GLib.DBusProxyFlags flags, string? name, string object_path, GLib.Cancellable? cancellable = null) throws GLib.Error;
	}
	[CCode (cheader_filename = "udisks/udisks.h", type_id = "udisks_manager_skeleton_get_type ()")]
	public class ManagerSkeleton : GLib.DBusInterfaceSkeleton, GLib.DBusInterface, UDisks.Manager {
		[CCode (has_construct_function = false, type = "UDisksManager*")]
		public ManagerSkeleton ();
	}
	[CCode (cheader_filename = "udisks/udisks.h", type_id = "udisks_object_manager_client_get_type ()")]
	public class ObjectManagerClient : GLib.DBusObjectManagerClient, GLib.AsyncInitable, GLib.DBusObjectManager, GLib.Initable {
		[CCode (cname = "udisks_object_manager_client_new", has_construct_function = false)]
		public async ObjectManagerClient (GLib.DBusConnection connection, GLib.DBusObjectManagerClientFlags flags, string? name, string object_path, GLib.Cancellable? cancellable) throws GLib.Error;
		[CCode (cname = "udisks_object_manager_client_new_for_bus", has_construct_function = false)]
		public async ObjectManagerClient.for_bus (GLib.BusType bus_type, GLib.DBusObjectManagerClientFlags flags, string name, string object_path, GLib.Cancellable? cancellable) throws GLib.Error;
		[CCode (has_construct_function = false, type = "GDBusObjectManager*")]
		public ObjectManagerClient.for_bus_sync (GLib.BusType bus_type, GLib.DBusObjectManagerClientFlags flags, string name, string object_path, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public static GLib.Type get_proxy_type (GLib.DBusObjectManagerClient manager, string object_path, string? interface_name, void* user_data);
		[CCode (has_construct_function = false, type = "GDBusObjectManager*")]
		public ObjectManagerClient.sync (GLib.DBusConnection connection, GLib.DBusObjectManagerClientFlags flags, string? name, string object_path, GLib.Cancellable? cancellable = null) throws GLib.Error;
	}
	[CCode (cheader_filename = "udisks/udisks.h", type_id = "udisks_object_proxy_get_type ()")]
	public class ObjectProxy : GLib.DBusObjectProxy, GLib.DBusObject, UDisks.Object {
		[CCode (has_construct_function = false)]
		public ObjectProxy (GLib.DBusConnection connection, string object_path);
	}
	[CCode (cheader_filename = "udisks/udisks.h", type_id = "udisks_object_skeleton_get_type ()")]
	public class ObjectSkeleton : GLib.DBusObjectSkeleton, GLib.DBusObject, UDisks.Object {
		[CCode (has_construct_function = false)]
		public ObjectSkeleton (string object_path);
		public void set_block (UDisks.Block? interface_);
		public void set_drive (UDisks.Drive? interface_);
		public void set_drive_ata (UDisks.DriveAta? interface_);
		public void set_encrypted (UDisks.Encrypted? interface_);
		public void set_filesystem (UDisks.Filesystem? interface_);
		public void set_job (UDisks.Job? interface_);
		public void set_loop (UDisks.Loop? interface_);
		public void set_manager (UDisks.Manager? interface_);
		public void set_partition (UDisks.Partition? interface_);
		public void set_partition_table (UDisks.PartitionTable? interface_);
		public void set_swapspace (UDisks.Swapspace? interface_);
	}
	[CCode (cheader_filename = "udisks/udisks.h", type_id = "udisks_partition_proxy_get_type ()")]
	public class PartitionProxy : GLib.DBusProxy, GLib.AsyncInitable, GLib.DBusInterface, GLib.Initable, UDisks.Partition {
		[CCode (cname = "udisks_partition_proxy_new", has_construct_function = false)]
		public async PartitionProxy (GLib.DBusConnection connection, GLib.DBusProxyFlags flags, string? name, string object_path, GLib.Cancellable? cancellable) throws GLib.Error;
		[CCode (cname = "udisks_partition_proxy_new_for_bus", has_construct_function = false)]
		public async PartitionProxy.for_bus (GLib.BusType bus_type, GLib.DBusProxyFlags flags, string name, string object_path, GLib.Cancellable? cancellable) throws GLib.Error;
		[CCode (has_construct_function = false, type = "UDisksPartition*")]
		public PartitionProxy.for_bus_sync (GLib.BusType bus_type, GLib.DBusProxyFlags flags, string name, string object_path, GLib.Cancellable? cancellable = null) throws GLib.Error;
		[CCode (has_construct_function = false, type = "UDisksPartition*")]
		public PartitionProxy.sync (GLib.DBusConnection connection, GLib.DBusProxyFlags flags, string? name, string object_path, GLib.Cancellable? cancellable = null) throws GLib.Error;
	}
	[CCode (cheader_filename = "udisks/udisks.h", type_id = "udisks_partition_skeleton_get_type ()")]
	public class PartitionSkeleton : GLib.DBusInterfaceSkeleton, GLib.DBusInterface, UDisks.Partition {
		[CCode (has_construct_function = false, type = "UDisksPartition*")]
		public PartitionSkeleton ();
	}
	[CCode (cheader_filename = "udisks/udisks.h", type_id = "udisks_partition_table_proxy_get_type ()")]
	public class PartitionTableProxy : GLib.DBusProxy, GLib.AsyncInitable, GLib.DBusInterface, GLib.Initable, UDisks.PartitionTable {
		[CCode (cname = "udisks_partition_table_proxy_new", has_construct_function = false)]
		public async PartitionTableProxy (GLib.DBusConnection connection, GLib.DBusProxyFlags flags, string? name, string object_path, GLib.Cancellable? cancellable) throws GLib.Error;
		[CCode (cname = "udisks_partition_table_proxy_new_for_bus", has_construct_function = false)]
		public async PartitionTableProxy.for_bus (GLib.BusType bus_type, GLib.DBusProxyFlags flags, string name, string object_path, GLib.Cancellable? cancellable) throws GLib.Error;
		[CCode (has_construct_function = false, type = "UDisksPartitionTable*")]
		public PartitionTableProxy.for_bus_sync (GLib.BusType bus_type, GLib.DBusProxyFlags flags, string name, string object_path, GLib.Cancellable? cancellable = null) throws GLib.Error;
		[CCode (has_construct_function = false, type = "UDisksPartitionTable*")]
		public PartitionTableProxy.sync (GLib.DBusConnection connection, GLib.DBusProxyFlags flags, string? name, string object_path, GLib.Cancellable? cancellable = null) throws GLib.Error;
	}
	[CCode (cheader_filename = "udisks/udisks.h", type_id = "udisks_partition_table_skeleton_get_type ()")]
	public class PartitionTableSkeleton : GLib.DBusInterfaceSkeleton, GLib.DBusInterface, UDisks.PartitionTable {
		[CCode (has_construct_function = false, type = "UDisksPartitionTable*")]
		public PartitionTableSkeleton ();
	}
	[CCode (cheader_filename = "udisks/udisks.h", copy_function = "g_boxed_copy", free_function = "g_boxed_free", type_id = "udisks_partition_type_info_get_type ()")]
	[Compact]
	public class PartitionTypeInfo {
		public UDisks.PartitionTypeInfoFlags flags;
		public weak string table_subtype;
		public weak string table_type;
		public weak string type;
		public void free ();
	}
	[CCode (cheader_filename = "udisks/udisks.h", type_id = "udisks_swapspace_proxy_get_type ()")]
	public class SwapspaceProxy : GLib.DBusProxy, GLib.AsyncInitable, GLib.DBusInterface, GLib.Initable, UDisks.Swapspace {
		[CCode (cname = "udisks_swapspace_proxy_new", has_construct_function = false)]
		public async SwapspaceProxy (GLib.DBusConnection connection, GLib.DBusProxyFlags flags, string? name, string object_path, GLib.Cancellable? cancellable) throws GLib.Error;
		[CCode (cname = "udisks_swapspace_proxy_new_for_bus", has_construct_function = false)]
		public async SwapspaceProxy.for_bus (GLib.BusType bus_type, GLib.DBusProxyFlags flags, string name, string object_path, GLib.Cancellable? cancellable) throws GLib.Error;
		[CCode (has_construct_function = false, type = "UDisksSwapspace*")]
		public SwapspaceProxy.for_bus_sync (GLib.BusType bus_type, GLib.DBusProxyFlags flags, string name, string object_path, GLib.Cancellable? cancellable = null) throws GLib.Error;
		[CCode (has_construct_function = false, type = "UDisksSwapspace*")]
		public SwapspaceProxy.sync (GLib.DBusConnection connection, GLib.DBusProxyFlags flags, string? name, string object_path, GLib.Cancellable? cancellable = null) throws GLib.Error;
	}
	[CCode (cheader_filename = "udisks/udisks.h", type_id = "udisks_swapspace_skeleton_get_type ()")]
	public class SwapspaceSkeleton : GLib.DBusInterfaceSkeleton, GLib.DBusInterface, UDisks.Swapspace {
		[CCode (has_construct_function = false, type = "UDisksSwapspace*")]
		public SwapspaceSkeleton ();
	}
	[CCode (cheader_filename = "udisks/udisks.h", type_id = "udisks_block_get_type ()")]
	public interface Block : GLib.Object {
		public async bool call_add_configuration_item (GLib.Variant arg_item, GLib.Variant arg_options, GLib.Cancellable? cancellable) throws GLib.Error;
		public bool call_add_configuration_item_sync (GLib.Variant arg_item, GLib.Variant arg_options, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public async bool call_format (string arg_type, GLib.Variant arg_options, GLib.Cancellable? cancellable) throws GLib.Error;
		public bool call_format_sync (string arg_type, GLib.Variant arg_options, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public async bool call_get_secret_configuration (GLib.Variant arg_options, GLib.Cancellable? cancellable, out GLib.Variant out_configuration) throws GLib.Error;
		public bool call_get_secret_configuration_sync (GLib.Variant arg_options, out GLib.Variant out_configuration, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public async bool call_open_for_backup (GLib.Variant arg_options, GLib.UnixFDList? fd_list, GLib.Cancellable? cancellable, out GLib.Variant out_fd, out GLib.UnixFDList out_fd_list) throws GLib.Error;
		public bool call_open_for_backup_sync (GLib.Variant arg_options, GLib.UnixFDList? fd_list, out GLib.Variant out_fd, out GLib.UnixFDList out_fd_list, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public async bool call_open_for_restore (GLib.Variant arg_options, GLib.UnixFDList? fd_list, GLib.Cancellable? cancellable, out GLib.Variant out_fd, out GLib.UnixFDList out_fd_list) throws GLib.Error;
		public bool call_open_for_restore_sync (GLib.Variant arg_options, GLib.UnixFDList? fd_list, out GLib.Variant out_fd, out GLib.UnixFDList out_fd_list, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public async bool call_remove_configuration_item (GLib.Variant arg_item, GLib.Variant arg_options, GLib.Cancellable? cancellable) throws GLib.Error;
		public bool call_remove_configuration_item_sync (GLib.Variant arg_item, GLib.Variant arg_options, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public async bool call_update_configuration_item (GLib.Variant arg_old_item, GLib.Variant arg_new_item, GLib.Variant arg_options, GLib.Cancellable? cancellable) throws GLib.Error;
		public bool call_update_configuration_item_sync (GLib.Variant arg_old_item, GLib.Variant arg_new_item, GLib.Variant arg_options, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public void complete_add_configuration_item (owned GLib.DBusMethodInvocation invocation);
		public void complete_format (owned GLib.DBusMethodInvocation invocation);
		public void complete_get_secret_configuration (owned GLib.DBusMethodInvocation invocation, GLib.Variant configuration);
		public void complete_open_for_backup (owned GLib.DBusMethodInvocation invocation, GLib.UnixFDList? fd_list, GLib.Variant fd);
		public void complete_open_for_restore (owned GLib.DBusMethodInvocation invocation, GLib.UnixFDList? fd_list, GLib.Variant fd);
		public void complete_remove_configuration_item (owned GLib.DBusMethodInvocation invocation);
		public void complete_update_configuration_item (owned GLib.DBusMethodInvocation invocation);
		public static unowned GLib.DBusInterfaceInfo interface_info ();
		public static uint override_properties (GLib.ObjectClass klass, uint property_id_begin);
		[NoAccessorMethod]
		public abstract GLib.Variant configuration { owned get; set; }
		[NoAccessorMethod]
		public abstract string crypto_backing_device { owned get; set; }
		[NoAccessorMethod]
		public abstract string device { owned get; set; }
		[NoAccessorMethod]
		public abstract uint64 device_number { get; set; }
		[NoAccessorMethod]
		public abstract string drive { owned get; set; }
		[NoAccessorMethod]
		public abstract bool hint_auto { get; set; }
		[NoAccessorMethod]
		public abstract string hint_icon_name { owned get; set; }
		[NoAccessorMethod]
		public abstract bool hint_ignore { get; set; }
		[NoAccessorMethod]
		public abstract string hint_name { owned get; set; }
		[NoAccessorMethod]
		public abstract bool hint_partitionable { get; set; }
		[NoAccessorMethod]
		public abstract bool hint_system { get; set; }
		[NoAccessorMethod]
		public abstract string id_label { owned get; set; }
		[NoAccessorMethod]
		public abstract string id_type { owned get; set; }
		[NoAccessorMethod]
		public abstract string id_usage { owned get; set; }
		[NoAccessorMethod]
		public abstract string id_uuid { owned get; set; }
		[NoAccessorMethod]
		public abstract string id_version { owned get; set; }
		[NoAccessorMethod]
		public abstract string preferred_device { owned get; set; }
		[NoAccessorMethod]
		public abstract bool read_only { get; set; }
		[NoAccessorMethod]
		public abstract uint64 size { get; set; }
		[CCode (array_length = false, array_null_terminated = true)]
		[NoAccessorMethod]
		public abstract string[] symlinks { owned get; set; }
		public virtual signal bool handle_add_configuration_item (GLib.DBusMethodInvocation invocation, GLib.Variant arg_item, GLib.Variant arg_options);
		public virtual signal bool handle_format (GLib.DBusMethodInvocation invocation, string arg_type, GLib.Variant arg_options);
		public virtual signal bool handle_get_secret_configuration (GLib.DBusMethodInvocation invocation, GLib.Variant arg_options);
		public virtual signal bool handle_open_for_backup (GLib.DBusMethodInvocation invocation, GLib.UnixFDList? fd_list, GLib.Variant arg_options);
		public virtual signal bool handle_open_for_restore (GLib.DBusMethodInvocation invocation, GLib.UnixFDList? fd_list, GLib.Variant arg_options);
		public virtual signal bool handle_remove_configuration_item (GLib.DBusMethodInvocation invocation, GLib.Variant arg_item, GLib.Variant arg_options);
		public virtual signal bool handle_update_configuration_item (GLib.DBusMethodInvocation invocation, GLib.Variant arg_old_item, GLib.Variant arg_new_item, GLib.Variant arg_options);
	}
	[CCode (cheader_filename = "udisks/udisks.h", type_id = "udisks_drive_get_type ()")]
	public interface Drive : GLib.Object {
		public async bool call_eject (GLib.Variant arg_options, GLib.Cancellable? cancellable) throws GLib.Error;
		public bool call_eject_sync (GLib.Variant arg_options, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public void complete_eject (owned GLib.DBusMethodInvocation invocation);
		public static unowned GLib.DBusInterfaceInfo interface_info ();
		public static uint override_properties (GLib.ObjectClass klass, uint property_id_begin);
		[NoAccessorMethod]
		public abstract string connection_bus { owned get; set; }
		[NoAccessorMethod]
		public abstract bool ejectable { get; set; }
		[NoAccessorMethod]
		public abstract string media { owned get; set; }
		[NoAccessorMethod]
		public abstract bool media_available { get; set; }
		[NoAccessorMethod]
		public abstract bool media_change_detected { get; set; }
		[CCode (array_length = false, array_null_terminated = true)]
		[NoAccessorMethod]
		public abstract string[] media_compatibility { owned get; set; }
		[NoAccessorMethod]
		public abstract bool media_removable { get; set; }
		[NoAccessorMethod]
		public abstract string model { owned get; set; }
		[NoAccessorMethod]
		public abstract bool optical { get; set; }
		[NoAccessorMethod]
		public abstract bool optical_blank { get; set; }
		[NoAccessorMethod]
		public abstract uint optical_num_audio_tracks { get; set; }
		[NoAccessorMethod]
		public abstract uint optical_num_data_tracks { get; set; }
		[NoAccessorMethod]
		public abstract uint optical_num_sessions { get; set; }
		[NoAccessorMethod]
		public abstract uint optical_num_tracks { get; set; }
		[NoAccessorMethod]
		public abstract bool removable { get; set; }
		[NoAccessorMethod]
		public abstract string revision { owned get; set; }
		[NoAccessorMethod]
		public abstract int rotation_rate { get; set; }
		[NoAccessorMethod]
		public abstract string seat { owned get; set; }
		[NoAccessorMethod]
		public abstract string serial { owned get; set; }
		[NoAccessorMethod]
		public abstract uint64 size { get; set; }
		[NoAccessorMethod]
		public abstract string sort_key { owned get; set; }
		[NoAccessorMethod]
		public abstract uint64 time_detected { get; set; }
		[NoAccessorMethod]
		public abstract uint64 time_media_detected { get; set; }
		[NoAccessorMethod]
		public abstract string vendor { owned get; set; }
		[NoAccessorMethod]
		public abstract string wwn { owned get; set; }
		public virtual signal bool handle_eject (GLib.DBusMethodInvocation invocation, GLib.Variant arg_options);
	}
	[CCode (cheader_filename = "udisks/udisks.h", type_id = "udisks_drive_ata_get_type ()")]
	public interface DriveAta : GLib.Object {
		public async bool call_smart_get_attributes (GLib.Variant arg_options, GLib.Cancellable? cancellable, out GLib.Variant out_attributes) throws GLib.Error;
		public bool call_smart_get_attributes_sync (GLib.Variant arg_options, out GLib.Variant out_attributes, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public async bool call_smart_selftest_abort (GLib.Variant arg_options, GLib.Cancellable? cancellable) throws GLib.Error;
		public bool call_smart_selftest_abort_sync (GLib.Variant arg_options, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public async bool call_smart_selftest_start (string arg_type, GLib.Variant arg_options, GLib.Cancellable? cancellable) throws GLib.Error;
		public bool call_smart_selftest_start_sync (string arg_type, GLib.Variant arg_options, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public async bool call_smart_update (GLib.Variant arg_options, GLib.Cancellable? cancellable) throws GLib.Error;
		public bool call_smart_update_sync (GLib.Variant arg_options, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public void complete_smart_get_attributes (owned GLib.DBusMethodInvocation invocation, GLib.Variant attributes);
		public void complete_smart_selftest_abort (owned GLib.DBusMethodInvocation invocation);
		public void complete_smart_selftest_start (owned GLib.DBusMethodInvocation invocation);
		public void complete_smart_update (owned GLib.DBusMethodInvocation invocation);
		public static unowned GLib.DBusInterfaceInfo interface_info ();
		public static uint override_properties (GLib.ObjectClass klass, uint property_id_begin);
		[NoAccessorMethod]
		public abstract bool smart_enabled { get; set; }
		[NoAccessorMethod]
		public abstract bool smart_failing { get; set; }
		[NoAccessorMethod]
		public abstract int smart_num_attributes_failed_in_the_past { get; set; }
		[NoAccessorMethod]
		public abstract int smart_num_attributes_failing { get; set; }
		[NoAccessorMethod]
		public abstract int64 smart_num_bad_sectors { get; set; }
		[NoAccessorMethod]
		public abstract uint64 smart_power_on_seconds { get; set; }
		[NoAccessorMethod]
		public abstract int smart_selftest_percent_remaining { get; set; }
		[NoAccessorMethod]
		public abstract string smart_selftest_status { owned get; set; }
		[NoAccessorMethod]
		public abstract bool smart_supported { get; set; }
		[NoAccessorMethod]
		public abstract double smart_temperature { get; set; }
		[NoAccessorMethod]
		public abstract uint64 smart_updated { get; set; }
		public virtual signal bool handle_smart_get_attributes (GLib.DBusMethodInvocation invocation, GLib.Variant arg_options);
		public virtual signal bool handle_smart_selftest_abort (GLib.DBusMethodInvocation invocation, GLib.Variant arg_options);
		public virtual signal bool handle_smart_selftest_start (GLib.DBusMethodInvocation invocation, string arg_type, GLib.Variant arg_options);
		public virtual signal bool handle_smart_update (GLib.DBusMethodInvocation invocation, GLib.Variant arg_options);
	}
	[CCode (cheader_filename = "udisks/udisks.h", type_id = "udisks_encrypted_get_type ()")]
	public interface Encrypted : GLib.Object {
		public async bool call_change_passphrase (string arg_passphrase, string arg_new_passphrase, GLib.Variant arg_options, GLib.Cancellable? cancellable) throws GLib.Error;
		public bool call_change_passphrase_sync (string arg_passphrase, string arg_new_passphrase, GLib.Variant arg_options, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public async bool call_lock (GLib.Variant arg_options, GLib.Cancellable? cancellable) throws GLib.Error;
		public bool call_lock_sync (GLib.Variant arg_options, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public async bool call_unlock (string arg_passphrase, GLib.Variant arg_options, GLib.Cancellable? cancellable, out string out_cleartext_device) throws GLib.Error;
		public bool call_unlock_sync (string arg_passphrase, GLib.Variant arg_options, out string out_cleartext_device, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public void complete_change_passphrase (owned GLib.DBusMethodInvocation invocation);
		public void complete_lock (owned GLib.DBusMethodInvocation invocation);
		public void complete_unlock (owned GLib.DBusMethodInvocation invocation, string cleartext_device);
		public static unowned GLib.DBusInterfaceInfo interface_info ();
		public static uint override_properties (GLib.ObjectClass klass, uint property_id_begin);
		public virtual signal bool handle_change_passphrase (GLib.DBusMethodInvocation invocation, string arg_passphrase, string arg_new_passphrase, GLib.Variant arg_options);
		public virtual signal bool handle_lock (GLib.DBusMethodInvocation invocation, GLib.Variant arg_options);
		public virtual signal bool handle_unlock (GLib.DBusMethodInvocation invocation, string arg_passphrase, GLib.Variant arg_options);
	}
	[CCode (cheader_filename = "udisks/udisks.h", type_id = "udisks_filesystem_get_type ()")]
	public interface Filesystem : GLib.Object {
		public async bool call_mount (GLib.Variant arg_options, GLib.Cancellable? cancellable, out string out_mount_path) throws GLib.Error;
		public bool call_mount_sync (GLib.Variant arg_options, out string out_mount_path, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public async bool call_set_label (string arg_label, GLib.Variant arg_options, GLib.Cancellable? cancellable) throws GLib.Error;
		public bool call_set_label_sync (string arg_label, GLib.Variant arg_options, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public async bool call_unmount (GLib.Variant arg_options, GLib.Cancellable? cancellable) throws GLib.Error;
		public bool call_unmount_sync (GLib.Variant arg_options, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public void complete_mount (owned GLib.DBusMethodInvocation invocation, string mount_path);
		public void complete_set_label (owned GLib.DBusMethodInvocation invocation);
		public void complete_unmount (owned GLib.DBusMethodInvocation invocation);
		public static unowned GLib.DBusInterfaceInfo interface_info ();
		public static uint override_properties (GLib.ObjectClass klass, uint property_id_begin);
		[CCode (array_length = false, array_null_terminated = true)]
		[NoAccessorMethod]
		public abstract string[] mount_points { owned get; set; }
		public virtual signal bool handle_mount (GLib.DBusMethodInvocation invocation, GLib.Variant arg_options);
		public virtual signal bool handle_set_label (GLib.DBusMethodInvocation invocation, string arg_label, GLib.Variant arg_options);
		public virtual signal bool handle_unmount (GLib.DBusMethodInvocation invocation, GLib.Variant arg_options);
	}
	[CCode (cheader_filename = "udisks/udisks.h", type_id = "udisks_job_get_type ()")]
	public interface Job : GLib.Object {
		public async bool call_cancel (GLib.Variant arg_options, GLib.Cancellable? cancellable) throws GLib.Error;
		public bool call_cancel_sync (GLib.Variant arg_options, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public void complete_cancel (owned GLib.DBusMethodInvocation invocation);
		public void emit_completed (bool arg_success, string arg_message);
		public static unowned GLib.DBusInterfaceInfo interface_info ();
		public static uint override_properties (GLib.ObjectClass klass, uint property_id_begin);
		[NoAccessorMethod]
		public abstract uint64 expected_end_time { get; set; }
		[CCode (array_length = false, array_null_terminated = true)]
		[NoAccessorMethod]
		public abstract string[] objects { owned get; set; }
		[NoAccessorMethod]
		public abstract double progress { get; set; }
		[NoAccessorMethod]
		public abstract uint64 start_time { get; set; }
		public virtual signal void completed (bool arg_success, string arg_message);
		public virtual signal bool handle_cancel (GLib.DBusMethodInvocation invocation, GLib.Variant arg_options);
	}
	[CCode (cheader_filename = "udisks/udisks.h", type_id = "udisks_loop_get_type ()")]
	public interface Loop : GLib.Object {
		public async bool call_delete (GLib.Variant arg_options, GLib.Cancellable? cancellable) throws GLib.Error;
		public bool call_delete_sync (GLib.Variant arg_options, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public async bool call_set_autoclear (bool arg_value, GLib.Variant arg_options, GLib.Cancellable? cancellable) throws GLib.Error;
		public bool call_set_autoclear_sync (bool arg_value, GLib.Variant arg_options, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public void complete_delete (owned GLib.DBusMethodInvocation invocation);
		public void complete_set_autoclear (owned GLib.DBusMethodInvocation invocation);
		public static unowned GLib.DBusInterfaceInfo interface_info ();
		public static uint override_properties (GLib.ObjectClass klass, uint property_id_begin);
		[NoAccessorMethod]
		public abstract bool autoclear { get; set; }
		[NoAccessorMethod]
		public abstract string backing_file { owned get; set; }
		[NoAccessorMethod]
		public abstract uint setup_by_uid { get; set; }
		public virtual signal bool handle_delete (GLib.DBusMethodInvocation invocation, GLib.Variant arg_options);
		public virtual signal bool handle_set_autoclear (GLib.DBusMethodInvocation invocation, bool arg_value, GLib.Variant arg_options);
	}
	[CCode (cheader_filename = "udisks/udisks.h", type_id = "udisks_manager_get_type ()")]
	public interface Manager : GLib.Object {
		public async bool call_loop_setup (GLib.Variant arg_fd, GLib.Variant arg_options, GLib.UnixFDList? fd_list, GLib.Cancellable? cancellable, out string out_resulting_device, out GLib.UnixFDList out_fd_list) throws GLib.Error;
		public bool call_loop_setup_sync (GLib.Variant arg_fd, GLib.Variant arg_options, GLib.UnixFDList? fd_list, out string out_resulting_device, out GLib.UnixFDList out_fd_list, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public void complete_loop_setup (owned GLib.DBusMethodInvocation invocation, GLib.UnixFDList? fd_list, string resulting_device);
		public static unowned GLib.DBusInterfaceInfo interface_info ();
		public static uint override_properties (GLib.ObjectClass klass, uint property_id_begin);
		[NoAccessorMethod]
		public abstract string version { owned get; set; }
		public virtual signal bool handle_loop_setup (GLib.DBusMethodInvocation invocation, GLib.UnixFDList? fd_list, GLib.Variant arg_fd, GLib.Variant arg_options);
	}
	[CCode (cheader_filename = "udisks/udisks.h", type_id = "udisks_object_get_type ()")]
	public interface Object : GLib.DBusObject, GLib.Object {
		public UDisks.Block get_block ();
		public UDisks.Drive get_drive ();
		public UDisks.DriveAta get_drive_ata ();
		public UDisks.Encrypted get_encrypted ();
		public UDisks.Filesystem get_filesystem ();
		public UDisks.Job get_job ();
		public UDisks.Loop get_loop ();
		public UDisks.Manager get_manager ();
		public UDisks.Partition get_partition ();
		public UDisks.PartitionTable get_partition_table ();
		public UDisks.Swapspace get_swapspace ();
		[NoAccessorMethod]
		public abstract UDisks.Block block { owned get; set; }
		[NoAccessorMethod]
		public abstract UDisks.Drive drive { owned get; set; }
		[NoAccessorMethod]
		public abstract UDisks.DriveAta drive_ata { owned get; set; }
		[NoAccessorMethod]
		public abstract UDisks.Encrypted encrypted { owned get; set; }
		[NoAccessorMethod]
		public abstract UDisks.Filesystem filesystem { owned get; set; }
		[NoAccessorMethod]
		public abstract UDisks.Job job { owned get; set; }
		[NoAccessorMethod]
		public abstract UDisks.Loop loop { owned get; set; }
		[NoAccessorMethod]
		public abstract UDisks.Manager manager { owned get; set; }
		[NoAccessorMethod]
		public abstract UDisks.Partition partition { owned get; set; }
		[NoAccessorMethod]
		public abstract UDisks.PartitionTable partition_table { owned get; set; }
		[NoAccessorMethod]
		public abstract UDisks.Swapspace swapspace { owned get; set; }
	}
	[CCode (cheader_filename = "udisks/udisks.h", type_id = "udisks_partition_get_type ()")]
	public interface Partition : GLib.Object {
		public async bool call_delete (GLib.Variant arg_options, GLib.Cancellable? cancellable) throws GLib.Error;
		public bool call_delete_sync (GLib.Variant arg_options, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public async bool call_set_flags (uint64 arg_flags, GLib.Variant arg_options, GLib.Cancellable? cancellable) throws GLib.Error;
		public bool call_set_flags_sync (uint64 arg_flags, GLib.Variant arg_options, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public async bool call_set_name (string arg_name, GLib.Variant arg_options, GLib.Cancellable? cancellable) throws GLib.Error;
		public bool call_set_name_sync (string arg_name, GLib.Variant arg_options, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public async bool call_set_type (string arg_type, GLib.Variant arg_options, GLib.Cancellable? cancellable) throws GLib.Error;
		public bool call_set_type_sync (string arg_type, GLib.Variant arg_options, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public void complete_delete (owned GLib.DBusMethodInvocation invocation);
		public void complete_set_flags (owned GLib.DBusMethodInvocation invocation);
		public void complete_set_name (owned GLib.DBusMethodInvocation invocation);
		public void complete_set_type (owned GLib.DBusMethodInvocation invocation);
		public static unowned GLib.DBusInterfaceInfo interface_info ();
		public static uint override_properties (GLib.ObjectClass klass, uint property_id_begin);
		[NoAccessorMethod]
		public abstract uint64 flags { get; set; }
		[NoAccessorMethod]
		public abstract bool is_contained { get; set; }
		[NoAccessorMethod]
		public abstract bool is_container { get; set; }
		[NoAccessorMethod]
		public abstract string name { owned get; set; }
		[NoAccessorMethod]
		public abstract uint number { get; set; }
		[NoAccessorMethod]
		public abstract uint64 offset { get; set; }
		[NoAccessorMethod]
		public abstract uint64 size { get; set; }
		[NoAccessorMethod]
		public abstract string table { owned get; set; }
		[NoAccessorMethod]
		public abstract string type_ { owned get; set; }
		[NoAccessorMethod]
		public abstract string uuid { owned get; set; }
		public virtual signal bool handle_delete (GLib.DBusMethodInvocation invocation, GLib.Variant arg_options);
		public virtual signal bool handle_set_flags (GLib.DBusMethodInvocation invocation, uint64 arg_flags, GLib.Variant arg_options);
		public virtual signal bool handle_set_name (GLib.DBusMethodInvocation invocation, string arg_name, GLib.Variant arg_options);
		public virtual signal bool handle_set_type (GLib.DBusMethodInvocation invocation, string arg_type, GLib.Variant arg_options);
	}
	[CCode (cheader_filename = "udisks/udisks.h", type_id = "udisks_partition_table_get_type ()")]
	public interface PartitionTable : GLib.Object {
		public async bool call_create_partition (uint64 arg_offset, uint64 arg_size, string arg_type, string arg_name, GLib.Variant arg_options, GLib.Cancellable? cancellable, out string out_created_partition) throws GLib.Error;
		public bool call_create_partition_sync (uint64 arg_offset, uint64 arg_size, string arg_type, string arg_name, GLib.Variant arg_options, out string out_created_partition, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public void complete_create_partition (owned GLib.DBusMethodInvocation invocation, string created_partition);
		public static unowned GLib.DBusInterfaceInfo interface_info ();
		public static uint override_properties (GLib.ObjectClass klass, uint property_id_begin);
		[NoAccessorMethod]
		public abstract string type_ { owned get; set; }
		public virtual signal bool handle_create_partition (GLib.DBusMethodInvocation invocation, uint64 arg_offset, uint64 arg_size, string arg_type, string arg_name, GLib.Variant arg_options);
	}
	[CCode (cheader_filename = "udisks/udisks.h", type_id = "udisks_swapspace_get_type ()")]
	public interface Swapspace : GLib.Object {
		public async bool call_start (GLib.Variant arg_options, GLib.Cancellable? cancellable) throws GLib.Error;
		public bool call_start_sync (GLib.Variant arg_options, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public async bool call_stop (GLib.Variant arg_options, GLib.Cancellable? cancellable) throws GLib.Error;
		public bool call_stop_sync (GLib.Variant arg_options, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public void complete_start (owned GLib.DBusMethodInvocation invocation);
		public void complete_stop (owned GLib.DBusMethodInvocation invocation);
		public static unowned GLib.DBusInterfaceInfo interface_info ();
		public static uint override_properties (GLib.ObjectClass klass, uint property_id_begin);
		[NoAccessorMethod]
		public abstract bool active { get; set; }
		public virtual signal bool handle_start (GLib.DBusMethodInvocation invocation, GLib.Variant arg_options);
		public virtual signal bool handle_stop (GLib.DBusMethodInvocation invocation, GLib.Variant arg_options);
	}
	[CCode (cheader_filename = "udisks/udisks.h", cprefix = "UDISKS_ERROR_")]
	public enum Error {
		FAILED,
		CANCELLED,
		ALREADY_CANCELLED,
		NOT_AUTHORIZED,
		NOT_AUTHORIZED_CAN_OBTAIN,
		NOT_AUTHORIZED_DISMISSED,
		ALREADY_MOUNTED,
		NOT_MOUNTED,
		OPTION_NOT_PERMITTED,
		MOUNTED_BY_OTHER_USER,
		ALREADY_UNMOUNTING,
		NOT_SUPPORTED,
		TIMED_OUT,
		WOULD_WAKEUP,
		DEVICE_BUSY;
		public static GLib.Quark quark ();
	}
	[CCode (cheader_filename = "udisks/udisks.h", cprefix = "UDISKS_PARTITION_TYPE_INFO_FLAGS_")]
	[Flags]
	public enum PartitionTypeInfoFlags {
		NONE,
		SWAP,
		RAID,
		HIDDEN,
		CREATE_ONLY,
		SYSTEM
	}
	[CCode (cheader_filename = "udisks/udisks.h", cname = "UDISKS_ERROR_NUM_ENTRIES")]
	public const int ERROR_NUM_ENTRIES;
	[CCode (cheader_filename = "udisks/udisks.h", cname = "UDISKS_MAJOR_VERSION")]
	public const int MAJOR_VERSION;
	[CCode (cheader_filename = "udisks/udisks.h", cname = "UDISKS_MICRO_VERSION")]
	public const int MICRO_VERSION;
	[CCode (cheader_filename = "udisks/udisks.h", cname = "UDISKS_MINOR_VERSION")]
	public const int MINOR_VERSION;
	[CCode (cheader_filename = "udisks/udisks.h")]
	public static unowned GLib.DBusInterfaceInfo block_interface_info ();
	[CCode (cheader_filename = "udisks/udisks.h")]
	public static uint block_override_properties (GLib.ObjectClass klass, uint property_id_begin);
	[CCode (cheader_filename = "udisks/udisks.h")]
	public static unowned GLib.DBusInterfaceInfo drive_ata_interface_info ();
	[CCode (cheader_filename = "udisks/udisks.h")]
	public static uint drive_ata_override_properties (GLib.ObjectClass klass, uint property_id_begin);
	[CCode (cheader_filename = "udisks/udisks.h")]
	public static unowned GLib.DBusInterfaceInfo drive_interface_info ();
	[CCode (cheader_filename = "udisks/udisks.h")]
	public static uint drive_override_properties (GLib.ObjectClass klass, uint property_id_begin);
	[CCode (cheader_filename = "udisks/udisks.h")]
	public static unowned GLib.DBusInterfaceInfo encrypted_interface_info ();
	[CCode (cheader_filename = "udisks/udisks.h")]
	public static uint encrypted_override_properties (GLib.ObjectClass klass, uint property_id_begin);
	[CCode (cheader_filename = "udisks/udisks.h")]
	public static unowned GLib.DBusInterfaceInfo filesystem_interface_info ();
	[CCode (cheader_filename = "udisks/udisks.h")]
	public static uint filesystem_override_properties (GLib.ObjectClass klass, uint property_id_begin);
	[CCode (cheader_filename = "udisks/udisks.h")]
	public static unowned GLib.DBusInterfaceInfo job_interface_info ();
	[CCode (cheader_filename = "udisks/udisks.h")]
	public static uint job_override_properties (GLib.ObjectClass klass, uint property_id_begin);
	[CCode (cheader_filename = "udisks/udisks.h")]
	public static unowned GLib.DBusInterfaceInfo loop_interface_info ();
	[CCode (cheader_filename = "udisks/udisks.h")]
	public static uint loop_override_properties (GLib.ObjectClass klass, uint property_id_begin);
	[CCode (cheader_filename = "udisks/udisks.h")]
	public static unowned GLib.DBusInterfaceInfo manager_interface_info ();
	[CCode (cheader_filename = "udisks/udisks.h")]
	public static uint manager_override_properties (GLib.ObjectClass klass, uint property_id_begin);
	[CCode (cheader_filename = "udisks/udisks.h")]
	public static unowned GLib.DBusInterfaceInfo partition_interface_info ();
	[CCode (cheader_filename = "udisks/udisks.h")]
	public static uint partition_override_properties (GLib.ObjectClass klass, uint property_id_begin);
	[CCode (cheader_filename = "udisks/udisks.h")]
	public static unowned GLib.DBusInterfaceInfo partition_table_interface_info ();
	[CCode (cheader_filename = "udisks/udisks.h")]
	public static uint partition_table_override_properties (GLib.ObjectClass klass, uint property_id_begin);
	[CCode (cheader_filename = "udisks/udisks.h")]
	public static unowned GLib.DBusInterfaceInfo swapspace_interface_info ();
	[CCode (cheader_filename = "udisks/udisks.h")]
	public static uint swapspace_override_properties (GLib.ObjectClass klass, uint property_id_begin);
}
